#!/bin/bash
#
# Manipulate UFW firewall rules for BitTorrent traffic


# define the target app profile
TN='transmission'

# define the target port number
TP='51413'


allow(){
    # ensure firewall is enabled before continuing
    ensure_enabled

    local rs=$(rule_status)

    # ensure rule is not already added before continuing
    if [[ $rs =~ ^(DENY|PARTIAL)$ ]]; then

        # remove rules beforehand if they are already partially added
        if [[ $rs = PARTIAL ]]; then
            deny
        fi

        # use an app profile if one exists (otherwise allow the port)
        if sudo ufw app info "$TN" &>/dev/null; then
            local rule="$TN"
        else
            local rule="in from any to any port $TP"
        fi

        # add rule then then reload firewall if it succeeds
        eval "sudo ufw allow $rule" && reloadufw
    else
        info 'Already ALLOW'
    fi
}


deny(){
    # ensure firewall is enabled before continuing
    ensure_enabled

    local changes errors

    local rs=$(rule_status)

    # ensure rule is already fully or partially added before continuing
    if [[ $rs = ALLOW ]]; then

        # check if there are port rules
        if grep -Eq "$TP (\(v6\))? +ALLOW +Anywhere( \(v6\))?" <<<"$status"; then
            if sudo ufw delete allow in from any to any port "$TP"; then
                changes=1
            else
                errors=1
            fi
        fi

        # check if there are app profile rules
        if grep -Eq "$TN (\(v6\))? +ALLOW +Anywhere( \(v6\))?" <<<"$status"; then
            if sudo ufw delete allow "$TN"; then
                changes=1
            else
                errors=1
            fi
        fi

    elif [[ $rs = PARTIAL ]]; then

        local port portlist ports

        # create a list of matching ports (in descending order)
        # portlist=$(sudo ufw status numbered | sed 's/^\[ \?//;s/\]//' | awk "(\$2 == \"$TP\") || (\$2 == \"$TN\") {print \$1}" | sort -nr)
        # portlist=$(sudo ufw status numbered | awk "{ gsub(\"^\\\[ ?|\\\]\", \"\") } (\$2 == \"$TP\") || (\$2 == \"$TN\") {print \$1}" | sort -nr)
        portlist=$(sudo ufw status numbered | grep -oP "(?<=\[)[1-9][0-9]*(?=\] ($TP|$TN) (\(v6\))?  )" | sort -nr)

        ports=($portlist)

        # delete each port
        for port in "${ports[@]}"; do
            if [[ $port =~ ^[1-9][0-9]*$ ]] && sudo ufw delete "$port"; then
                changes=1
            else
                errors=1
            fi
        done

    else
        info 'Already DENY'
        return 0
    fi

    if (( changes == 1 )); then
        reloadufw
    fi

    if (( errors == 1 )); then
        error 'Experienced an unknown error while removing firewall rules'
        exit 1
    fi
}


ensure_enabled(){
    # execute only if firewall is not enabled
    if ! firewall_state; then

        sudo ufw enable

        # exit if firewall failed to enable
        if ! firewall_state; then
            error 'Unable to enable firewall'
            exit 1
        fi
    fi
}


error(){
    echo "ERROR: $*" >&2
}


firewall_state(){
    local i state

    # retry up to 5 times in the event of failure
    for ((i=1; i<=5; i++)); do
        # store ufw status in global variable
        status=$(sudo ufw status 2>/dev/null)

        # state=$(awk 'NR==1 {print $NF}' <<<"$status")
        state=$(awk '/^Status: / {print $2}' <<<"$status")
        if [[ $state = active ]]; then
            return 0
        elif [[ $state = inactive ]]; then
            return 1
        fi

        sleep 1
    done

    error 'Experienced an unknown error while checking firewall state'
    exit 1
}


info(){
    echo "INFO: $*"
}


# ensure process isn't locked
lock_acquire(){
    local i

    # retry up to 30 times (6 seconds in total)
    for i in {1..30}; do

        # return successfully if process is unlocked
        lockfile-check --use-pid "$LOCKFILE" || return 0

        # wait 1/5 sec before retrying
        sleep 0.2

    done

    # this point is only reachable upon failure
    error "Unable to ensure process isn't already locked"

    # warn about lock file if it exists
    if [[ -f $LOCKFILE.lock ]]; then
        echo "Please see lock file '$LOCKFILE.lock'" >&2
    fi

    exit 1
}


lock_create(){
    # configure trap to remove lock upon exit (except SIGKILL)
    trap lock_remove EXIT

    # ensure process isn't locked (wait up to 5 seconds if it is) then lock it it
    lockfile-create --retry 1 --use-pid "$LOCKFILE" && return 0

    # this point is only reachable upon failure
    error 'Unable to create lock file (does it already exist?)'

    # warn about lock file if it exists
    if [[ -f $LOCKFILE.lock ]]; then
        echo "Please see lock file '$LOCKFILE.lock'" >&2
    fi

    exit 1
}


lock_remove(){
    # remove the lock
    lockfile-remove "$LOCKFILE"
}


main(){
    # declare global configs
    PROGRAM=${0##*/}
    LOCKFILE=$HOME/.$PROGRAM

    if (( $# == 0 )); then
        echo "$PROGRAM: missing operand" >&2
        echo "Try '$PROGRAM --help' for more information." >&2
        exit 1
    elif (( $# == 1 )) && [[ $1 =~ ^(-h|--help|help)$ ]]; then
        cat <<-EOF
		Usage: $PROGRAM COMMAND

		allow               create firewall rule allowing incoming connections
		deny                remove firewall rules without prompting
		state               display state of firewall
		status              display firewall rule status

		Manipulate UFW firewall rules for BitTorrent traffic.
		EOF
        exit 0
    elif (( $# == 1 )) && [[ ${1,,} =~ ^(allow|deny|state|status)$ ]]; then
        local cmd=${1,,}
    else
        error "Invalid argument"
        exit 1
    fi

    # allow & deny must lock the process during UFW operations
    if [[ $cmd =~ ^(allow|deny)$ ]]; then
        lock_create
        "$cmd"
        lock_remove
    # state & status must ensure process is not locked before continuing
    elif [[ $cmd =~ ^(state|status)$ ]]; then
        lock_acquire
        "$cmd"
    fi
}


reloadufw(){
    local i

    # retry reload up to 3 times in the event of failure
    for i in {1..3}; do

        # break loop if reload is successful
        sudo ufw reload && break

        # wait 1 sec before retrying
        sleep 1

    done
}


remove(){
    if (( $# == 1 )) && [[ $1 =~ ^[1-9][0-9]*$ ]]; then
        sudo ufw delete "$1"
    elif (( $# == 2 )) && [[ $1 =~ ^[1-9][0-9]*$ ]] && [[ $2 = --force ]]; then
        sudo ufw delete "$1" <<<y
    fi
}


rule_status(){
    # count port rules
    local n=$(grep -cE "^$TP (\(v6\))?  " <<<"$status")

    # count profile rules
    local p=$(grep -cE "^$TN (\(v6\))?  " <<<"$status")

    # check whether there are strictly port or profile rules added
    if ( (( n == 2 )) && (( p == 0 )) ) \
    || ( (( n == 0 )) && (( p == 2 )) ); then
        echo ALLOW
    # check whether there are no rules added
    elif (( n == 0 )) && (( p == 0 )); then
        echo DENY
    else
        echo PARTIAL
    fi
}


state(){
    if firewall_state; then
        echo ACTIVE
    else
        echo INACTIVE
    fi
}


status(){
    if firewall_state; then
        rule_status
    else
        echo INACTIVE
    fi
}


main "$@"
